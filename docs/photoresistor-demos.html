<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Photoresistor Demonstrations</title>
<style>
body {font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f5f5f5; line-height: 1.6;}
.demo-section {background: white; padding: 25px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);}
h1 {color: #2c3e50; border-bottom: 3px solid #f39c12; padding-bottom: 10px;}
h2 {color: #34495e; margin-top: 0;}
h3 {color: #16a085;}
.circuit-diagram {background: #ecf0f1; padding: 20px; border-radius: 5px; font-family: 'Courier New', monospace; margin: 15px 0; overflow-x: auto;}
.theory-box {background: #e8f4f8; padding: 15px; border-left: 4px solid #3498db; margin: 15px 0;}
.math-box {background: #fef5e7; padding: 15px; border-left: 4px solid #f39c12; margin: 15px 0;}
.code-section {background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; margin: 15px 0;}
table {width: 100%; border-collapse: collapse; margin: 15px 0;}
th, td {border: 1px solid #bdc3c7; padding: 10px; text-align: left;}
th {background: #34495e; color: white;}
</style>
</head>
<body>
<nav class="doc-nav">
    <div class="nav-container">
        <a href="https://thmscmpg.github.io/CircuitNotes/index.html" class="home-btn"><i class="fas fa-house"></i> Home</a>

        <div class="dropdown-wrapper">
            <label for="page-select">Jump to:</label>
            <select id="page-select" onchange="window.location.href=this.value;">
                <option value="" disabled selected>Select a Document</option>
                <option value="basic-5v-circuits.html">Basic 5V DC Circuits</option>
                <option value="led-demos.html">Standard LED Demos</option>
                <option value="rgb-led-demos.html">RGB LED Control</option>
                <option value="photoresistor-demos.html">Photoresistors (LDR)</option>
                <option value="rotary-encoder-demos.html">Rotary Encoders</option>
                <option value="matrix-keypad-theory.html">Matrix Keypads</option>
                <option value="oled-buzzer-theory.html">OLED & Buzzers</option>
                <option value="seven-segment-dip.html">7-Segment & DIP</option>
                <option value="master-reference.html">Master Reference</option>
            </select>
        </div>
    </div>
</nav>
<h1>☀️ Photoresistor (LDR) Circuit Demonstrations</h1>

<div class="demo-section">
<h2>Understanding Photoresistors</h2>

<div class="theory-box">
<strong>What is a Photoresistor?</strong><br>
A photoresistor (Light Dependent Resistor or LDR) is a passive component whose resistance decreases with increasing incident light intensity. They're made from semiconductor materials like cadmium sulfide (CdS).

<br><br><strong>Physical Principle:</strong><br>
When photons strike the semiconductor material, they provide energy to electrons, promoting them from the valence band to the conduction band. This increases the number of charge carriers, reducing resistance.

<br><br><strong>Typical Characteristics:</strong>
<ul>
<li><strong>Dark Resistance:</strong> 1MΩ to 10MΩ</li>
<li><strong>Bright Resistance:</strong> 100Ω to 1kΩ</li>
<li><strong>Response Time:</strong> 10-100ms (relatively slow)</li>
<li><strong>Spectral Peak:</strong> ~550nm (green light)</li>
</ul>

<strong>Important Note:</strong> LDRs are non-linear and have significant unit-to-unit variation. They're best for relative measurements, not absolute light level quantification.
</div>

<h3>Resistance vs. Light Intensity</h3>
<table>
<tr><th>Light Condition</th><th>Illuminance (lux)</th><th>Typical Resistance</th></tr>
<tr><td>Complete Darkness</td><td>0</td><td>1-10 MΩ</td></tr>
<tr><td>Moonlight</td><td>0.1</td><td>100-500 kΩ</td></tr>
<tr><td>Dim Indoor</td><td>10-50</td><td>10-50 kΩ</td></tr>
<tr><td>Normal Room</td><td>100-300</td><td>5-10 kΩ</td></tr>
<tr><td>Bright Office</td><td>500-1000</td><td>1-2 kΩ</td></tr>
<tr><td>Direct Sunlight</td><td>10,000-100,000</td><td>100-500 Ω</td></tr>
</table>
</div>

<div class="demo-section">
<h2>Demo 1: Automatic Night Light (Voltage Divider)</h2>

<h3>Circuit Diagram</h3>
<div class="circuit-diagram">
+5V
 |
 |
[LDR] (Photoresistor)
 |
 +---> A0 (Analog Input)
 |
[10kΩ] (Fixed Resistor)
 |
GND

LED Circuit:
Pin 9 (PWM) ---[220Ω]---LED---|>|---GND
</div>

<h3>Theory</h3>
<div class="theory-box">
<strong>Voltage Divider Principle:</strong><br>
The LDR and fixed resistor form a voltage divider. The voltage at the junction (Vout) varies with light level:

<br><br>Vout = Vin × (R2 / (R1 + R2))
<br><br>Where R1 = LDR, R2 = Fixed resistor

<br><br><strong>Why 10kΩ?</strong><br>
The fixed resistor should be chosen near the middle of the LDR's resistance range for maximum sensitivity. With an LDR ranging from 1kΩ to 100kΩ, a 10kΩ resistor provides good response across typical indoor lighting conditions.
</div>

<h3>Calculations</h3>
<div class="math-box">
<strong>Example Voltage Outputs:</strong><br><br>

<strong>Bright Conditions (RLDR = 1kΩ):</strong><br>
Vout = 5V × (10kΩ / (1kΩ + 10kΩ))<br>
Vout = 5V × (10/11) = 4.55V<br>
ADC reading = 4.55V × 1023/5V = 931<br><br>

<strong>Dark Conditions (RLDR = 100kΩ):</strong><br>
Vout = 5V × (10kΩ / (100kΩ + 10kΩ))<br>
Vout = 5V × (10/110) = 0.45V<br>
ADC reading = 0.45V × 1023/5V = 92<br><br>

<strong>Mid-Range (RLDR = 10kΩ):</strong><br>
Vout = 5V × (10kΩ / (10kΩ + 10kΩ))<br>
Vout = 5V × 0.5 = 2.5V<br>
ADC reading = 512
</div>

<h3>Arduino Code</h3>
<div class="code-section">
// Automatic Night Light
const int LDR_PIN = A0;
const int LED_PIN = 9;

// Calibration values (adjust based on your LDR and environment)
const int DARK_THRESHOLD = 300;   // Below this = dark
const int BRIGHT_THRESHOLD = 700; // Above this = bright

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("Automatic Night Light");
  Serial.println("Cover sensor to activate light");
}

void loop() {
  // Read light level
  int lightLevel = analogRead(LDR_PIN);
  
  // Map to LED brightness (inverted: darker = brighter LED)
  int ledBrightness = map(lightLevel, DARK_THRESHOLD, BRIGHT_THRESHOLD, 255, 0);
  ledBrightness = constrain(ledBrightness, 0, 255);
  
  // Set LED brightness
  analogWrite(LED_PIN, ledBrightness);
  
  // Display status
  Serial.print("Light Level: ");
  Serial.print(lightLevel);
  Serial.print(" | LED: ");
  Serial.print(ledBrightness);
  Serial.print(" | Status: ");
  
  if(lightLevel < DARK_THRESHOLD) {
    Serial.println("DARK - Light ON");
  } else if(lightLevel > BRIGHT_THRESHOLD) {
    Serial.println("BRIGHT - Light OFF");
  } else {
    Serial.println("DIMMING");
  }
  
  delay(100);
}
</div>

<h3>Use Cases</h3>
<ul>
<li><strong>Automatic Lighting:</strong> Street lights, garden lights, hallway lights</li>
<li><strong>Display Brightness:</strong> Auto-dimming screens and instruments</li>
<li><strong>Photography:</strong> Light meters, automatic camera settings</li>
<li><strong>Solar Tracking:</strong> Optimizing solar panel orientation</li>
</ul>
</div>

<div class="demo-section">
<h2>Demo 2: Light-Activated Alarm with Threshold Detection</h2>

<h3>Circuit Diagram</h3>
<div class="circuit-diagram">
Voltage Divider (same as Demo 1):
+5V ---[LDR]---+---[10kΩ]--- GND
               |
               +---> A0

Buzzer Circuit:
Pin 8 ---[100Ω]---BUZZER(+)
                    |
                   GND

Status LEDs:
Pin 10 ---[220Ω]---LED(Green)---|>|---GND  (Normal)
Pin 11 ---[220Ω]---LED(Red)------|>|---GND  (Alarm)
</div>

<h3>Theory</h3>
<div class="theory-box">
<strong>Threshold Detection:</strong><br>
Digital systems often need to make binary decisions from analog inputs. A threshold with hysteresis prevents rapid switching near the boundary (known as "chattering").

<br><br><strong>Hysteresis:</strong><br>
The system has two thresholds:
<ul>
<li><strong>Upper Threshold:</strong> Must exceed this to trigger alarm</li>
<li><strong>Lower Threshold:</strong> Must drop below this to cancel alarm</li>
</ul>

The gap between thresholds prevents oscillation when light level hovers near the boundary.

<br><br><strong>Schmitt Trigger Behavior:</strong><br>
This software implementation mimics a Schmitt trigger, a fundamental circuit in digital electronics used for noise-immune switching.
</div>

<h3>Calculations</h3>
<div class="math-box">
<strong>Hysteresis Gap Calculation:</strong><br><br>

Assume we want to detect when someone opens a dark box (light suddenly increases):<br><br>

Normal (dark) ADC value: ~200<br>
Light exposed ADC value: ~800<br><br>

Upper threshold (alarm ON): 500<br>
Lower threshold (alarm OFF): 400<br>
Hysteresis gap: 100 counts = 0.49V<br><br>

This 100-count gap prevents false triggering from minor fluctuations or shadows.
</div>

<h3>Arduino Code</h3>
<div class="code-section">
// Light-Activated Alarm with Hysteresis
const int LDR_PIN = A0;
const int BUZZER_PIN = 8;
const int LED_NORMAL = 10;  // Green
const int LED_ALARM = 11;   // Red

const int UPPER_THRESHOLD = 500;  // Trigger alarm
const int LOWER_THRESHOLD = 400;  // Cancel alarm
const int ALARM_DURATION = 5000;  // 5 seconds

bool alarmActive = false;
unsigned long alarmStartTime = 0;

void setup() {
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(LED_NORMAL, OUTPUT);
  pinMode(LED_ALARM, OUTPUT);
  
  Serial.begin(9600);
  Serial.println("Light-Activated Alarm System");
  Serial.println("Monitoring for sudden light increase...");
  
  digitalWrite(LED_NORMAL, HIGH);  // Start in normal state
}

void loop() {
  int lightLevel = analogRead(LDR_PIN);
  
  // Hysteresis threshold logic
  if(!alarmActive && lightLevel > UPPER_THRESHOLD) {
    // Light suddenly increased - trigger alarm
    alarmActive = true;
    alarmStartTime = millis();
    Serial.println("\n*** ALARM TRIGGERED! ***");
  }
  else if(alarmActive && lightLevel < LOWER_THRESHOLD) {
    // Light back to normal (but keep alarm for duration)
    // Don't cancel immediately
  }
  
  // Check alarm duration
  if(alarmActive && (millis() - alarmStartTime > ALARM_DURATION)) {
    alarmActive = false;
    Serial.println("Alarm reset\n");
  }
  
  // Update outputs
  if(alarmActive) {
    // Sound buzzer and flash red LED
    digitalWrite(LED_NORMAL, LOW);
    digitalWrite(LED_ALARM, (millis() / 200) % 2);  // Flash at 2.5 Hz
    tone(BUZZER_PIN, 2000, 100);  // 2kHz beep
    
    Serial.print("ALARM! Light: ");
    Serial.print(lightLevel);
    Serial.print(" Time remaining: ");
    Serial.print((ALARM_DURATION - (millis() - alarmStartTime)) / 1000);
    Serial.println("s");
  }
  else {
    // Normal state
    digitalWrite(LED_NORMAL, HIGH);
    digitalWrite(LED_ALARM, LOW);
    noTone(BUZZER_PIN);
    
    Serial.print("Normal - Light: ");
    Serial.println(lightLevel);
  }
  
  delay(100);
}
</div>

<h3>Use Cases</h3>
<ul>
<li><strong>Security Systems:</strong> Detect when dark enclosures are opened</li>
<li><strong>Safety Monitoring:</strong> Ensure machine guards are in place</li>
<li><strong>Environmental Control:</strong> Greenhouse light monitoring</li>
<li><strong>Scientific Experiments:</strong> Light-triggered data logging</li>
</ul>
</div>

<div class="demo-section">
<h2>Advanced Topics</h2>

<h3>Improving LDR Measurements</h3>
<div class="theory-box">
<strong>1. Averaging for Noise Reduction:</strong><br>
Take multiple readings and average them to reduce noise from AC lighting flicker (50/60 Hz) and random fluctuations.

<br><br><strong>2. Exponential Moving Average:</strong><br>
Smoothed = α × Current + (1-α) × Previous<br>
where α = 0.1 to 0.3 for good smoothing

<br><br><strong>3. Calibration:</strong><br>
Store minimum and maximum readings during a calibration period, then map all subsequent readings to this range for consistent operation across different LDRs and environments.

<br><br><strong>4. Logarithmic Response:</strong><br>
LDR resistance varies roughly logarithmically with light intensity. For linear light measurement, apply log() transformation to ADC values.
</div>

<h3>Practical Design Considerations</h3>
<table>
<tr><th>Issue</th><th>Solution</th></tr>
<tr><td>AC Light Flicker</td><td>Average readings over 20ms (one AC cycle)</td></tr>
<tr><td>Temperature Drift</td><td>Use ambient temperature compensation or differential sensing</td></tr>
<tr><td>Aging Effects</td><td>Periodic recalibration, compare against reference</td></tr>
<tr><td>Limited Range</td><td>Use different fixed resistor values for different applications</td></tr>
<tr><td>Slow Response</td><td>Use photodiodes or phototransistors for faster response</td></tr>
</table>

<h3>Alternative Light Sensors</h3>
<div class="theory-box">
<strong>Photodiode:</strong> Fast response (μs), linear output, current-based, good for high-speed applications
<br><br><strong>Phototransistor:</strong> Amplified photodiode, faster than LDR, moderate cost
<br><br><strong>Digital Light Sensors (BH1750, TSL2561):</strong> I2C/SPI interface, calibrated lux output, excellent accuracy
<br><br><strong>Solar Cells:</strong> Generate voltage from light, can power low-current circuits directly
</div>
</div>

</body>
</html>
