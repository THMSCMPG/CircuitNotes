<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rotary Encoder Demonstrations</title>
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  background: #f5f5f5;
  line-height: 1.6;
}
.demo-section {
  background: white;
  padding: 25px;
  margin: 20px 0;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
h1 {
  color: #2c3e50;
  border-bottom: 3px solid #9b59b6;
  padding-bottom: 10px;
}
h2 {
  color: #34495e;
  margin-top: 0;
}
h3 {
  color: #16a085;
}
.circuit-diagram {
  background: #ecf0f1;
  padding: 20px;
  border-radius: 5px;
  font-family: 'Courier New', monospace;
  margin: 15px 0;
  overflow-x: auto;
}
.theory-box {
  background: #e8f4f8;
  padding: 15px;
  border-left: 4px solid #3498db;
  margin: 15px 0;
}
.math-box {
  background: #fef5e7;
  padding: 15px;
  border-left: 4px solid #f39c12;
  margin: 15px 0;
}
.code-section {
  background: #2c3e50;
  color: #ecf0f1;
  padding: 15px;
  border-radius: 5px;
  overflow-x: auto;
  margin: 15px 0;
}
.waveform {
  background: #fff;
  border: 2px solid #333;
  padding: 10px;
  font-family: monospace;
  margin: 10px 0;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 15px 0;
}
th, td {
  border: 1px solid #bdc3c7;
  padding: 10px;
  text-align: left;
}
th {
  background: #34495e;
  color: white;
}
</style>
</head>
<body>

<h1>ðŸ”„ Rotary Encoder Demonstrations</h1>

<div class="demo-section">
<h2>Understanding Rotary Encoders</h2>

<div class="theory-box">
<strong>What is a Rotary Encoder?</strong><br>
A rotary encoder is an electromechanical device that converts angular position or motion into digital signals. Unlike potentiometers (which are analog), encoders provide unlimited rotation and precise position tracking.

<br><br><strong>Types:</strong>
<ul>
<li><strong>Incremental Encoders:</strong> Detect direction and amount of rotation (most common hobby type)</li>
<li><strong>Absolute Encoders:</strong> Provide exact position at all times (typically expensive)</li>
</ul>

<strong>How It Works:</strong><br>
Incremental encoders have two output channels (A and B) that produce square wave signals 90Â° out of phase (quadrature signals). The phase relationship determines rotation direction.
</div>

<h3>Quadrature Signal Timing</h3>
<div class="waveform">
Clockwise Rotation:
         ___     ___     ___
A:   ___|   |___|   |___|   |___
       ___     ___     ___
B:  ___|   |___|   |___|   |___

A leads B by 90Â°

Counter-Clockwise:
         ___     ___     ___
A:   ___|   |___|   |___|   |___
           ___     ___     ___
B:  _____|   |___|   |___|   |___

B leads A by 90Â°
</div>

<h3>State Transition Table</h3>
<table>
<tr>
<th>Previous A</th>
<th>Previous B</th>
<th>Current A</th>
<th>Current B</th>
<th>Direction</th>
</tr>
<tr><td>0</td><td>0</td><td>0</td><td>1</td><td>CW</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td><td>CW</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>CW</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td><td>CW</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>0</td><td>CCW</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>CCW</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td><td>CCW</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>CCW</td></tr>
</table>
</div>

<div class="demo-section">
<h2>Demo 1: Volume Control Simulator</h2>

<h3>Circuit Diagram</h3>
<div class="circuit-diagram">
Rotary Encoder (KY-040 or similar)
                                
CLK (A) ---[10kÎ© pull-up]--- +5V
         |
         +---> Pin 2 (INT0)

DT  (B) ---[10kÎ© pull-up]--- +5V
         |
         +---> Pin 3 (INT1)

SW      ---[10kÎ© pull-up]--- +5V
         |
         +---> Pin 4

GND     ---> GND
+       ---> +5V (some modules)

Note: Many encoder modules have built-in pull-ups
</div>

<h3>Theory</h3>
<div class="theory-box">
<strong>Interrupt-Driven Design:</strong> Using hardware interrupts ensures no rotation pulses are missed, even when the main loop is busy. Arduino Uno has two external interrupts:
<ul>
<li>INT0 on Pin 2</li>
<li>INT1 on Pin 3</li>
</ul>

<strong>Debouncing:</strong> Mechanical encoders can produce contact bounce, creating false readings. Software debouncing filters these out by requiring a minimum time between valid transitions.
</div>

<h3>Calculations</h3>
<div class="math-box">
<strong>Resolution:</strong><br>
Typical hobby encoders: 20 pulses per revolution (PPR)<br>
With quadrature decoding: 20 Ã— 4 = 80 counts per revolution<br><br>

<strong>Angular Resolution:</strong><br>
360Â° / 80 counts = 4.5Â° per count<br><br>

<strong>Debounce Time:</strong><br>
Typical mechanical bounce: 5-50ms<br>
Software filter: Ignore transitions < 1ms apart<br>
Minimum time = 1000 microseconds
</div>

<h3>Arduino Code</h3>
<div class="code-section">
// Rotary Encoder Volume Control
const int PIN_A = 2;      // CLK
const int PIN_B = 3;      // DT
const int PIN_SW = 4;     // Switch (button)

volatile int encoderPos = 50;  // Start at 50% volume
volatile int lastEncoded = 0;
volatile unsigned long lastInterrupt = 0;

int volume = 50;  // 0-100%
bool muted = false;

void setup() {
  pinMode(PIN_A, INPUT_PULLUP);
  pinMode(PIN_B, INPUT_PULLUP);
  pinMode(PIN_SW, INPUT_PULLUP);
  
  // Attach interrupts
  attachInterrupt(digitalPinToInterrupt(PIN_A), updateEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_B), updateEncoder, CHANGE);
  
  Serial.begin(9600);
  Serial.println("Volume Control Ready");
  printVolume();
}

void loop() {
  // Update volume from encoder position
  static int lastPos = encoderPos;
  if(encoderPos != lastPos) {
    volume = constrain(encoderPos, 0, 100);
    lastPos = encoderPos;
    printVolume();
  }
  
  // Check for button press (mute/unmute)
  static bool lastButton = HIGH;
  bool currentButton = digitalRead(PIN_SW);
  
  if(lastButton == HIGH && currentButton == LOW) {
    delay(50); // Debounce
    if(digitalRead(PIN_SW) == LOW) {
      muted = !muted;
      Serial.print("MUTED: ");
      Serial.println(muted ? "ON" : "OFF");
    }
  }
  lastButton = currentButton;
  
  delay(10);
}

void updateEncoder() {
  // Debouncing
  unsigned long interruptTime = micros();
  if(interruptTime - lastInterrupt < 1000) return;
  lastInterrupt = interruptTime;
  
  // Read current state
  int MSB = digitalRead(PIN_A);
  int LSB = digitalRead(PIN_B);
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncoded << 2) | encoded;
  
  // Determine direction
  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) {
    encoderPos++;
  }
  else if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) {
    encoderPos--;
  }
  
  lastEncoded = encoded;
}

void printVolume() {
  Serial.print("Volume: ");
  Serial.print(volume);
  Serial.print("% ");
  
  // Visual bar
  Serial.print("[");
  for(int i = 0; i < 20; i++) {
    if(i < volume / 5) Serial.print("=");
    else Serial.print(" ");
  }
  Serial.println("]");
}
</div>

<h3>Use Cases</h3>
<ul>
<li><strong>Audio Equipment:</strong> Volume, bass, treble controls</li>
<li><strong>User Interfaces:</strong> Menu navigation, value adjustment</li>
<li><strong>Robotics:</strong> Manual positioning, speed control</li>
<li><strong>3D Printers:</strong> Manual axis control</li>
</ul>
</div>

<div class="demo-section">
<h2>Demo 2: Digital Position Counter with Direction Display</h2>

<h3>Circuit Diagram</h3>
<div class="circuit-diagram">
Same as Demo 1, plus 3 LEDs:

Pin 9  ---[220Î©]---LED(Green)---|>|---GND   (CW indicator)
Pin 10 ---[220Î©]---LED(Red)-----|>|---GND   (CCW indicator)
Pin 11 ---[220Î©]---LED(Blue)----|>|---GND   (Position zero)
</div>

<h3>Theory</h3>
<div class="theory-box">
<strong>Absolute Position Tracking:</strong> By counting all encoder transitions, we can track absolute position from a known starting point (zero reference).

<br><br><strong>Applications in Motion Control:</strong>
<ul>
<li><strong>CNC Machines:</strong> Track tool position</li>
<li><strong>Robotics:</strong> Joint angle tracking</li>
<li><strong>Automated Systems:</strong> Linear actuator positioning</li>
</ul>

<strong>Encoder Resolution Enhancement:</strong> Quadrature decoding provides 4Ã— resolution increase by detecting both rising and falling edges of both channels.
</div>

<h3>Calculations</h3>
<div class="math-box">
<strong>Position Calculation:</strong><br>
If encoder has 20 PPR and we want to track degrees:<br><br>

Counts per revolution = 20 Ã— 4 = 80<br>
Degrees per count = 360Â° / 80 = 4.5Â°<br><br>

Position (degrees) = count Ã— 4.5Â°<br><br>

<strong>Linear Motion Example:</strong><br>
If encoder drives a lead screw with 2mm pitch:<br>
Linear distance = (count / 80) Ã— 2mm = count Ã— 0.025mm
</div>

<h3>Arduino Code</h3>
<div class="code-section">
// Position Counter with Direction Display
const int PIN_A = 2;
const int PIN_B = 3;
const int PIN_SW = 4;
const int LED_CW = 9;    // Green - Clockwise
const int LED_CCW = 10;  // Red - Counter-clockwise
const int LED_ZERO = 11; // Blue - At zero position

volatile long encoderCount = 0;
volatile int lastEncoded = 0;
volatile unsigned long lastInterrupt = 0;
volatile int lastDirection = 0;  // 1=CW, -1=CCW, 0=stopped

void setup() {
  pinMode(PIN_A, INPUT_PULLUP);
  pinMode(PIN_B, INPUT_PULLUP);
  pinMode(PIN_SW, INPUT_PULLUP);
  pinMode(LED_CW, OUTPUT);
  pinMode(LED_CCW, OUTPUT);
  pinMode(LED_ZERO, OUTPUT);
  
  attachInterrupt(digitalPinToInterrupt(PIN_A), updateEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_B), updateEncoder, CHANGE);
  
  Serial.begin(9600);
  Serial.println("Position Counter Ready");
  Serial.println("Press button to reset position");
}

void loop() {
  // Update display
  static long lastCount = -999;
  if(encoderCount != lastCount) {
    displayPosition();
    lastCount = encoderCount;
  }
  
  // Update direction LEDs
  if(lastDirection > 0) {
    digitalWrite(LED_CW, HIGH);
    digitalWrite(LED_CCW, LOW);
  } else if(lastDirection < 0) {
    digitalWrite(LED_CW, LOW);
    digitalWrite(LED_CCW, HIGH);
  } else {
    digitalWrite(LED_CW, LOW);
    digitalWrite(LED_CCW, LOW);
  }
  
  // Zero indicator
  digitalWrite(LED_ZERO, encoderCount == 0 ? HIGH : LOW);
  
  // Reset button
  if(digitalRead(PIN_SW) == LOW) {
    delay(50);
    if(digitalRead(PIN_SW) == LOW) {
      encoderCount = 0;
      Serial.println("\n*** POSITION RESET TO ZERO ***\n");
      delay(200);
    }
  }
  
  delay(100);
}

void updateEncoder() {
  unsigned long interruptTime = micros();
  if(interruptTime - lastInterrupt < 1000) return;
  lastInterrupt = interruptTime;
  
  int MSB = digitalRead(PIN_A);
  int LSB = digitalRead(PIN_B);
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncoded << 2) | encoded;
  
  if(sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) {
    encoderCount++;
    lastDirection = 1;
  }
  else if(sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) {
    encoderCount--;
    lastDirection = -1;
  }
  
  lastEncoded = encoded;
}

void displayPosition() {
  // Calculate degrees (assuming 20 PPR encoder)
  float degrees = (encoderCount % 80) * 4.5;
  int revolutions = encoderCount / 80;
  
  Serial.print("Count: ");
  Serial.print(encoderCount);
  Serial.print(" | Rev: ");
  Serial.print(revolutions);
  Serial.print(" | Angle: ");
  Serial.print(degrees, 1);
  Serial.print("Â° | Dir: ");
  Serial.println(lastDirection > 0 ? "CW" : (lastDirection < 0 ? "CCW" : "STOP"));
}
</div>

<h3>Use Cases</h3>
<ul>
<li><strong>Motor Position Feedback:</strong> Closed-loop control systems</li>
<li><strong>Robotic Arms:</strong> Joint angle measurement</li>
<li><strong>Scientific Instruments:</strong> Precision positioning</li>
<li><strong>Gaming Controllers:</strong> Infinite rotation input devices</li>
</ul>
</div>

</body>
</html>
